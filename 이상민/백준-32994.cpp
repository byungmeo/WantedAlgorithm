//#include <iostream>
//#include <queue>
//
//#define y first
//#define x second
//
//using namespace std;
//
//bool Board[1001][1001][5];
//
//struct Temp {
//    pair<int, int> Pos;
//    int Fish;
//};
//
//int main() {
//    // 조건 1. 설치된 위치를 기준으로 상하좌우 각 2칸 내로 같은 물고기 종류가 있으면 안된다.
//    // 조건 2. 설치된 위치에 만약 상하좌우에 격자가 존재한다면 각각 다른 물고기 종류 총 4종류가 전부 인접해야 한다.
//
//    // 해당 알고리즘의 시작은 조건 2부터 얘기가 나올 것 같다.
//    // 조건 2의 의미는 모서리 부분이 아닌 곳에는 모두 설치가 되어야 함을 의미한다.
//    // 이 말은 무조건 [1,1]에 아무 물고기 한 종류를 넣는다면 모서리 부터 계속해서 다양한 물고기들을 무작위로(마리가 중요하기 때문에)
//    // 배치함으로써 어느정도 문제를 해결할 수 있을 것이다.
//
//    // 변수 테이블 은 3중 배열로 해결 가능하다
//    // Board[i][j][f] 로 i는 세로 좌표, j는 가로 좌표 그리고 f는 물고기의 현재 배치를 저장하는 값이다.
//    // 마지막 f의 경우는 물고기 종류는 중요하지 않지만 해당 물고기가 있는 지를 비교 분석하기 위해 굳이 매번 반복문을 쓸 필요는 없으니 bool 타입으로 선언해
//    // 사용하는 것이 가장 좋아보인다.
//
//    int N, M;
//    std::cin >> N >> M;
//    // 그냥 해당 격자의 1,1 좌표에는 그냥 첫번째 물고기를 넣어두고 시작한다.
//    // 물고기 종류는 상관 없으니 괜찮다.
//    Board[1][1][0] = true;
//
//    // 모든 곳을 다 돌아야 하지만 내가 있는 좌표를 기준으로 돌아야 하고, 최대한 잘 채우기 위해서는 웬만해서는
//    // 한쪽 방향부터 최대한 많이 채워 놓는 것이 이점이기에 dfs를 활용한다.
//
//    queue<Temp> dfs;
//
//    dfs.push({{1, 1}, 0});
//
//    while (!dfs.empty()) {
//        auto [ Pos, Fish ] = dfs.front();
//        dfs.pop();
//
//        // 상하좌우로 인접한 칸이 모두 있는 경우
//        if (Pos.y - 1 >= 0 && Pos.y + 1 < M && Pos.x - 1 >= 0 && Pos.x + 1 < M) {
//
//        } else {
//
//        }
//    }
//
//    return 0;
//}

#include <iostream>

using namespace std;

void solve_fish_farm(int N, int M) {
    // 기본 패턴 정의 (5x5 패턴)
    // 하드코딩 처럼 각 5종류의 물고기를 조건 2개에 맞춰서 배치를 해둔다.
    // 1. 인접한 2칸 내에 같은 종류의 물고기가 없을 것
    // 2. 상하좌우에 물고기 배치가 가능한 경우에는 무조건 다 다른 물고기가 존재할 것
    int pattern[5][5] = {
            {1, 2, 3, 4, 5},
            {3, 4, 5, 1, 2},
            {5, 1, 2, 3, 4},
            {2, 3, 4, 5, 1},
            {4, 5, 1, 2, 3}
    };

    // 문제 이해 자체를 잘못했다. 사실 물고기의 수를 나타내는 것이 아니라 물고기 종류에 대해 표현하는 것인데...
    // 이 부분은 다음에 다른 문제를 풀어볼 때 참고해서 해봐야 겠다...
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            cout << pattern[i % 5][j % 5];
            if(j < M-1) cout << " ";
        }
        cout << "\n";
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;

    solve_fish_farm(N, M);

    return 0;
}