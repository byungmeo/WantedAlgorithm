//0 - 1, 1 - 2 ... 해서 가장 큰 수가 나오기 위한 조건
//
//        ex. 20 1 15 8 4 10 이라고 가정할 때
//20 15 10 8 4 1 순서 즉 가장 앞이 큰 수 일때
//
//20 - 15, 15 - 10, 10 - 8, 8 - 4, 4 - 1
//5 + 5 + 2 + 4 + 3 = 10 + 6 + 3 = 19
//
//근데 여기서 문제의 핵심은 절대 값 이라는 것 즉
//        음수에 대한 걱정을 할 필요 없이 차이가 전부 크면 된다.
//
//20 1 15 4 10 8
//20 - 1, 1 - 15, 15 - 4, 4 - 10, 10 - 8
//19, 14, 11, 6, 2
//33 + 17 + 2
//52
//
//1 20 4 15 8 10
//19 16 11 7 2
//55
//
//절대 값이 가장 크기 위해서는 서로 간의 숫자 차이가 커야 한다.
//
//8 20 1 15 4 10
//12 + 19 + 14 + 11 + 6
//31 + 25 + 6
//62
//
//이 케이스의 순서는 다음과 같다.
//우선 모든 숫자 중 가운데 값을 중심으로 2갈래로 나눈다.
//
//20, 15, 10 / 1, 4, 8
//여기서 핵심은 작은 그룹 중 가장 큰 수를 맨 먼저로 올린다.
//그 다음에는 쉽게 해결 가능하다.
//큰 수 그룹에서 큰 순서대로 내림 차순을, 작은 그룹에서는 작은 숫자부터 오름 차순으로 정리하면 된다.
//
//이렇게 하기까지 가장 필요한 행위는 즉 작은 그룹과 큰 그룹을 어떻게 나누는가?가 핵심이다.
//
//홀수일 경우 가운데 수는 어디에 두는 것이 좋은가?는 크게 생각할 필요 없다.
//그냥 맨 처음으로 올리면 된다. 즉 작은 수의 그룹에 더 많은 숫자가 들어가야 한다.

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    std::cin >> N;

    int A[10];
    for (int i = 0; i < N; i++) {
        std::cin >> A[i];
    }

    // 값 전부 정렬한다.
    sort(A, A + N);

    int Result = 0;
    vector<int> A1;

    // 중간 값을 맨 처음으로 할당한다.
    A1.push_back(A[N / 2]);

    // 만약 가운데 값과 큰 값이 같은 경우에 대해서 예외처리가 필요하다
    // 이런 경우는 작은 수 부터 넣어줘야 한다.
    // ex. 1, 3, 3 -> 3, 1, 3
    for (int i = 0; i < N / 2; i++) {
        if (A[N - 1] == A[N / 2] || A[N - 1] == 0) {
            A1.push_back(A[i]);
            A1.push_back(A[N - 1 - i]);
        } else {
            A1.push_back(A[N - 1 - i]);
            A1.push_back(A[i]);
        }
    }

    for (int i = 0; i < A1.size() - 1; i++) {
        Result += abs(A1[i] - A1[i + 1]);
    }

    printf("%d", Result);

    return 0;
}