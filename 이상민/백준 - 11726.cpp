// 위는 잘못 생각한 케이스
//#include <iostream>
//
//using namespace std;
//
//int NL[1002];
//
//int main()
//{
////    세로 2
////    가로 1: 1
////    가로 2: 2 (1, 1)
////    가로 3: 3 (1, 2), (2, 1) 원래 라면 4가지 케이스 여야 하지만 2 * 1 타일 이라 하나 조건은 충족 못해서  - 1
////    가로 4: 5 (1, 3), (2, 2)
////    가로 5: 7 (4, 1), (2, 3)
////    가로 6: 10 (4, 2), (2, 4), (3, 3)
////    가로 7: 14 (1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)
////    가로 8: (1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1)
////    가로 9: (1, 8), (2, 7) . . . (7, 2), (8, 1)
//// 가로가 짝수인 경우는 겹치는 구간이 존재 한다.
//// 즉 짝수일 때에 대해서 특정 경우 수가 중첩 되는 것을 방지 해야 할 필요가 있다.
//// 그림 상으로 볼 때는 짝수 쪽 에서는 반드시 짝수와 짝수 와의 중첩만 이루어 진다.
//// 홀수의 경우는 무조껀 세로 블록이 하나 있는 상태 에서 짝수 와의 중첩이 존재할 수 있다.
//
//// 홀수 개의 블록 키에는 무조건 i - 1 칸의 수에서 세로 1칸의 블록을 추가 해야 한다. 다만 반대도 가능하기 때문에 + 1을 더 해줘야 한다.
//// 짝수 개의 블록 키에는 2 * 2 조합 즉 2개 가지 케이스의 블록을 추가 해야 한다.
//// if (i % 2 == 1) NL[i] = NL[i - 1] + 2;
//// if (i % 2 == 0) NL[i] = NL[i - 2] * 2;
//
//    int N;
//    std::cin >> N;
//
//    NL[1] = 1;
//    NL[2] = 2;
//
//    for (int i = 3; i <= N; i++) {
//        if (i % 2 == 1) NL[i] = NL[i - 1] + 1;
//        else if (i % 2 == 0) NL[i] = NL[i - 2] * 2;
//    }
//
//    std::cout << NL[N] << std::endl;
//
//    return 0;
//}

// 정답을 보고 난 뒤에 케이스
// 근접한 것 같기도 한데... 아닌 것 같기도 하다.
// 만약 2 * 4를 만든다고 했을 때 나와야 하는 공식은 2 * 2에 2 * 2를 추가한다 이거나, 2 * 3에 2 * 1을 추가 해야 한다.
// 이게 5칸이 되면 3칸에 2칸을 추가하거나 4칸에 1칸을 추가하거나가 된다.
// 즉 NL[i] = NL[i - 2] + NL[i -1]이 된다는 것이다. 
// 다만 여기서 이해가 안가는 부분은 i - 2의 케이스에서는 2칸 짜리가 가로 2개가 나열 되거나 세로 2개가 나열되거나
// 이기 때문에 2가지 케이스라 * 2가 되어야 하지 않나... 싶은데 이 부분에 대한 설명은 따로 없거나 그냥 그렇게 이해해라
// 가 너무 많아 이 정도로 마무리 한다.
// 이건 정답 제출 하지 않고 나중에 다시 풀 수 있게 하려한다.
#include <iostream>

using namespace std;

int NL[1002];

int main()
{
    int N;
    std::cin >> N;

    NL[1] = 1;
    NL[2] = 2;

    for (int i = 3; i <= N; i++) {
        NL[i] = NL[i - 1] + NL [i - 2];
    }

    std::cout << NL[N] << std::endl;

    return 0;
}