#include <iostream>

using namespace std;

int N[12];

int main()
{
    int T, n;
    std::cin >> T;

    N[1] = 1;
    N[2] = 2;
    N[3] = 4;

    // 실제 코드에서 이리 짜면 안되지만 한번 시도해보고 싶었음
    // --T로 먼저 값을 줄여 0보다 크거나 같을 때 까지 순회한다.
    // 3을 Input 하면 2,1,0 순서대로 동작
    while (--T >= 0) {
        std::cin >> n;

        // 이전 계산에서 이미 결과가 나왔다면 굳이 또 계산할 필요는 없다.
        if (N[n] > 0) {
            std::cout << N[n] << endl;
            continue;
        }

        for (int i = 4; i <= n; i++) {
            if (N[i] > 0) continue;
            // 3은 1 + 2다. 그리고 2는 1 + 1, 2로 나누어진다. 그리고 3이다.
            // 하지만 경우의 수가 순서도 있기 때문에 1 + 1 + 1, 3, 1 + 2, 2 + 1로 총 4가지 경우를 가지고 있다.
            // N[i - 2] + N[i - 1]? 3은 자기 자신도 포함 이라 예외 처리를 위해 초기 값 설정 해두기
            // 4의 경우는 1 + 3이다.
            // 최소 숫자가 4는 아니기 때문에
            // 1 + 3, 3 + 1, 1 + 1 + 2, 1 + 2 + 1, 2 + 1 + 1, 1 + 1 + 1 + 1, 2 + 2
            // 총 7가지의 경우의 수가 나온다.
            // 어제 처럼 생각해보면 순서 상관 없이 처리하는 것을 생각해 볼때
            // 조합상 4는 1 + 3이고 3은 1 + 2고, 2는 1 + 1인 것을 감안하면
            // 각각 3,2,1을 뺀 숫자와 조합한 상태에서 1이 추가되는 케이스가 되기 때문에 이렇게 처리하면 될 것 같음.
            // N[i - 3] + N[i - 2] + N[i - 1] ?
            N[i] = N[i - 3] + N[i - 2] + N[i - 1];
        }
        std::cout << N[n] << endl;
    }

    return 0;
}